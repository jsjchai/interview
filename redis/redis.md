## redis
> Redis 指远程字典服务器 (Remote Dictionary Server)，是一款快速的开源内存中键值数据存储，可用作数据库、缓存、消息代理和队列

### 单线程
* Redis6.0之前设计为单线程
* Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。
* 早在Redis 4.0的时候就已经针对部分命令做了多线程化。主要是体现在大数据的异步删除功能上，例如unlink key、flushdb async、flushall async等

### 多线程
* 通过并发的方式来提升I/O的利用率和CPU的利用率
* Redis 6.0 只有在网络请求的接收和解析，以及请求后的数据通过网络返回时，使用了多线程。而数据读写操作还是由单线程来完成的

### 数据结构
* Strings 
* Lists 
* Sets 
* Sorted Sets
* Hashes 
* Bitmaps 
* HyperLogLogs 

### 复制和持久性
> Redis 采用的是主副本架构，并支持异步复制，用户执行此类复制时可以将数据复制到多个副本服务器。它能够提供更出色的读取性能（因为请求可以在多个服务器间进行拆分）和恢复功能（主服务器发生中断时）。为了实现持久性，Redis 支持时间点备份（将 Redis 数据集复制到磁盘）

### 高可用性和可扩展性
> Redis在单个主节点或群集拓扑中提供主副本架构。这让您可以构建高度可用的解决方案，从而提供一致的性能和可靠性。如果您需要调整群集大小，它还为您提供了多种选项，包括横向扩展、纵向缩减或扩展。这让您的群集能够根据您的需求而发展

### 持久化
> Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作
* RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。
* AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB

### 如何保证缓存和数据库数据的双写一致性
* 先更新缓存，再更新数据库
* 先更新数据库，再更新缓存
* 先删除缓存，再更新数据库
* 延时双删策略
* 先更新数据库，再删除缓存

### Redis的多路复用
> Redis的IO多路复用程序的所有功能都是通过包装操作系统的IO多路复用函数库来实现的。每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件

### 分布式锁
* SETNX + EXPIRE
* 使用Lua脚本(包含SETNX + EXPIRE两条指令)
  * Lua脚本来保证原子性
* SET的扩展命令
  * 表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取
* Redisson框架

### 常见问题
* 缓存雪崩
   * 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩
   * 解决
     * 加随机值
     * 缓存部署 
* 缓存击穿
   * key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮
   * 解决
     * 互斥锁
     * 热点数据不失效
 * 缓存穿透
   * key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源
   * 解决
     * 普隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力   
   
