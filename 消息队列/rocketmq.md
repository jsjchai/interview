## rocketmq
### RocketMQ  部署架构
![image](https://user-images.githubusercontent.com/13389058/110308182-c8c8e680-803a-11eb-8493-0b367a507c88.png)
* Nameserver
  *  Nameserver 集群，topic 的路由注册中心，为客户端根据 Topic 提供路由服务，从而引导客户端向 Broker 发送消息。Nameserver 之间的节点不通信。路由信息在Nameserver 集群中数据一致性采取的最终一致性
* Broker
  * 消息存储服务器，分为两种角色：Master 与 Slave。 在 RocketMQ 中，主服务承担读写操作，从服务器作为一个备份，当主服务器存在压力时，从服务器可以承担读服务（消息消费）
* Client
  * 消息客户端，包括 Producer(消息发送者)和 Consumer(消费消费者)．客户端在同一时间只会连接一台 nameserver，只有在连接出现异常时才会向尝试连接另外一台。客户端每隔 30s 向 Nameserver 发起 topic 的路由信息查询

### 消息订阅模型
> 发布与订阅模式
* topic
  * 一类消息的集合，消息发送者将一类消息发送到一个主题中
* consumegroup
  * 消息消费组，一个消费单位的“群体”，消费组首先在启动时需要订阅需要消费的 topic。一个 topic 可以被多个消费组订阅，同样一个消费组也可以订阅多个主题。一个消费组拥有多个消费者。
#### 消费模式
* 广播模式
  * 一个消费组内的所有消费者每一个都会处理 topic 中的每一条消息，通常用于刷新内存缓存
* 集群模式
  * 一个消费组内的所有消费者共同消费一个 topic 中的消息，即分工协作，一个消费者消费一部分数据，启动负载均衡
####  消费模型
* 顺序消费
* 并发消费

### 事务消息
> 事务消息并不是为了解决分布式事务，而是提供消息发送与业务落库的一致性，其实现原理就是一次分布式事务的具体运用

### 定时消息
> 所谓的定时消息就是将消息发送到 Broker，但消费端不会立即消费，而是要到指定延迟时间后才能被消费端消费

### 消息过滤
> 消息过滤是指消费端可以根据某些条件对一个 topic 中的消息进行过滤，即只消费一个主题下满足过滤条件的消息
* RocketMQ 目前主要的过滤机制是基于 tag 的过滤与基于消息属性的过滤，基于消息属性的过滤支持 SQL92 表达式，对消息进行过滤
