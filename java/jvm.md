## JDK8 Memory Model
![img](https://github.com/jsjchai/study-notes/blob/master/2019/jvm/img/jvm%E8%BF%90%E8%A1%8C%E6%A6%82%E8%BF%B0.png)
### 运行时数据区
1. 堆（Heap）
 > 堆是所有Java虚拟机线程之间共享的内存区域。它是在虚拟机启动时创建的。所有类实例和数组都在堆中分配（使用new运算符）。垃圾收集器管理的主要区域，可细分为新生代、老年带、Eden区、Form Survivor区、To Survivor区等。堆可以动态扩展或收缩，可以通过" -Xms -Xmx"控制其大小，在物理上处于不连续空间，只要逻辑上连续即可。
2. 方法区（Method area）
 > 所有Java虚拟机线程之间共享的内存。它是在虚拟机启动时创建的，由类加载器从字节码加载。只要加载它们的类加载器处于活动状态，方法区域中的数据就会保留在内存中。在JDK 8中，永久代被删除，HotSpot将方法区域存储在元空间（Metaspace）的独立本机内存空间中。默认情况下，可用于类元数据的本机内存量是无限制的。使用该选项MaxMetaspaceSize可以为用于类元数据的本机内存量设置上限。方法区存储以下信息：
 
     。类信息（字段/方法的数量，父类名称，接口名称，版本......）
     。方法和构造函数的字节码
     。每个类加载的运行时常量池
     
  * 运行时常量池（Runtime constant pool）
    * 方法区的一部分。用于存放编译期生成的各种字面量和符号应用
3. 程序计数器（The pc Register (Per Thread)）
> 每个线程都有自己的pc(程序计数器)寄存器，与线程同时创建。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。可以看作是当前线程所执行的字节码的行号指示器。
4. java虚拟机栈（Java Virtual Machine Stacks (Per Thread)）
> 每个线程私有的，生命周期与线程相同。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息
   * 栈帧（Stack Frame）
     栈帧是一个包含多个数据的数据结构，这些数据代表当前方法(被调用的方法)中线程的状态:
     * 调用栈（Operand Stack）  用于在（java）方法调用中传递参数，并在调用方法的堆栈顶部获取被调用方法的结果
     * 局部变量数组（Local variable array）  这个数组包含当前方法范围内的所有局部变量。这个数组可以保存基本类型、引用或返回地址。此数组的大小在编译时  计算。Java虚拟机使用局部变量在方法调用时传递参数，被调用方法的数组由调用方法的Operand Stack创建。
     * 运行时常量引用（Run-time constant pool reference） 当前类当前方法的常量池对象引用，jvm运行时，指向真实的内存地址   
5. 本地方法栈(Native method stack (Per Thread))
> 使用非Java语言编写并通过JNI调用的本机代码堆栈。因为它是一个native方法的堆栈，所以这个堆栈的行为完全依赖于底层操作系统。

### jps 虚拟机进程状况工具
```shell
  # 查询进程id并打印主类的全名（如果是jar包启动，则打印jar包路径）
  jps -l
```
### jstat 虚拟机统计信息监视工具
```shell
  #每100毫秒查询一次进程8080垃圾收集状况，一共查询20次
  jstat -gc 8080 100 20
```
### jinfo java配置信息工具
```shell
  #查看进程id47168虚拟机各项参数
  jinfo  47168
```
### jmap java内存映像工具
### jstack java堆栈跟踪工具
### HSDIS JIT生成代码反汇编

## GC
### 那些对象需要被回收

  * 程序在运行期间才能知道会创建那些对象，这部分内存的分配和回收都是动态的,垃圾回收器所关注就是这部分内存 如：
    * 接口的多个实现类需要的内存不一样
    * 一个方法中多个分支需要的内存不一样
  * 可达性分析算法： 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有引用链相连时，则证明此对象是不可用的
  ![img](https://github.com/jsjchai/study-notes/blob/master/2019/jvm/img/gc_roots.png)
  * 引用
    * 强引用  直接“Object obj = new Object()”的这类引用
    * 软引用  描述一些还有用但并非必需的对象  SoftReference
    * 弱引用  描述非必需的引用  WeakReference
    * 虚引用  在被垃圾回收器回收时收到一个系统通知 PhantomReference

### 垃圾收集算法

1. 标记-清除算法
2. 复制算法
3. 标记-整理算法

### 垃圾收集器

* Serial收集器
  * 单线程收集器
  * 新生代
  * 进行垃圾回收时，必须暂停其他所有的工作线程，直到它收集结束 
* ParNew收集器
  * Serial收集器的多线程版本
  * 新生代
  * 标记-整理算法
* Parallel Scavenge收集器
  * 达到一个可控制的吞吐量 
  * 新生代
  * 多线程
* Serial Old收集器
  * 老年代
  * 单线程收集器
* ParNew old收集器
  * Serial收集器的多线程版本
  * 老年代
  * 标记-整理算法
* CMS收集器
  * 获取最短回收停顿时间为目标的收集器
  * 标记-清除算法
  * 并发收集 
* G1收集器
  * 并行与并发
  * 分代收集
  * 空间整合 标记-整理算法
  * 可预测的停顿
* Epsilon（无操作的垃圾收集器）
  * No-Op垃圾收集器
  * 保证最低GC开销
* ZGC
  * 可伸缩低延迟垃圾收集器
  * 最大暂停时间为几毫秒
  * 暂停时间不会随堆或活动集大小（*）的增加而增加
  * Handle heaps 8MB-16TB 

## 虚拟机类加载机制
> 虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型
### 生命周期
* 加载 
* 验证
  * 文件格式验证
  * 元数据验证
  * 字节码验证
  * 符号引用验证 
* 准备
  * 正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配
* 解析
  * 虚拟机将常量池的符号引用替换为直接引用
  1. 类或接口的解析
  2. 字段解析
  3. 类方法解析
  4. 接口方法解析
* 初始化
 * 真正开始执行类中定义的java程序代码（字节码） 
* 使用
* 卸载

### 类加载器
> 通过一个类的全限定名来获取描述此类的二进制字节流用来加载到java虚拟机中
* 类层次划分
* OSGI
* 热部署
* 代码加密
#### 类型
* Bootstrap ClassLoader c++实现
* java.lang.ClassLoader java内部实现、
#### 分类
* 启动类加载器（Bootstrap ClassLoader）
* 扩展类加载器（Extension ClassLoader）
* 应用程序类加载器（Application ClassLoader）

### 双亲委派模型
> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载。
![类加载器双亲委派模型](https://github.com/jsjchai/interview/blob/main/java/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg)



### jvm调优
* OOM(OutOfMemoryError)
  * java堆溢出
  * 虚拟机栈和本地方法栈溢出
  * 方法区和运行时常量溢出
  * 本机直接内存溢出
* 内存泄露
  * 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏
* 锁优化
