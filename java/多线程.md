## 并发
* 多个任务交替执行
* 多个任务之间有可能还是串行

## 并行
* 同时执行

## 并发级别
### 阻塞
* synchronized
* 重入锁
### 无饥饿
* 非公平锁 高优先级的线程插队，低优先级线程产生饥饿
### 无障碍
* 非阻塞调度
### 无锁
### 无等待

## java内存模型（JMM）
* 原子性
  * long类型不是原子性的
* 可见性
  * 一个线程修改公共区域的值时，其他线程是否能够立即知道这个修改
* 有序性
  * 程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致
    * 指令重排可以保证串行语义一致，但是没有义务保证多线程的语义也一致
  * 指令不能重排：Happen-Before规则
    * 程序顺序原则
    * volatile
    * 锁规则
    * 传递性
    * 线程start()优先它的每一个动作
    * 线程的所有操作优先于线程的终结
    * 线程的中断（interrupt()）先于被中断线程的代码
    * 对象的构造函数的执行、结束先于finalize()方法
 
## 进程
* 系统进行资源分配和调度的基本单位，是操作系统结构的基础
* 线程就是轻量级进程，是程序执行的最小单位

## 线程状态
* NEW
* RUNNABLE
* BLOCKED
* WAITING
* TIMED_WAITING
* TERMINATED

## volatile
* 保证变量的可见性
* 有序性
* 只能确保一个线程修改了数据后，其他线程能够看到这个修改。但当两个线程同时修改某一个数据时，依然会产生冲突
* 无法保证一些复合操作的原子性，比如： i++
* 实现原理
  * https://www.cnblogs.com/paddix/p/5428507.html
* 缓存一致性协议MESI MESI协议保证了每个缓存变量中使用的共享变量的副本都是一致的
  * 如果在短时间内产生大量的cas操作在加上 volatile的嗅探机制则会不断地占用总线带宽，导致总线流量激增
  * [Volatile 和 CAS 的弊端之总线风暴](https://cloud.tencent.com/developer/article/1707875)

## synchronized
* 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象锁
* 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前对象锁
* 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁

