## 优化SQL语句
* 以mysql版本5.6为例

### select语句
 1. **优化查询的主要考虑因素**
    * 为了使慢速SELECT ... WHERE查询更快，首先要检查的是是否可以添加索引
    * 隔离和调整查询中花费时间过多的任何部分，例如函数调用
    * 最小化查询中全表扫描的次数，特别是对于大表
    * 通过ANALYZE TABLE定期使用该语句来使表统计信息保持最新，因此优化器具有构造有效执行计划所需的信息
    * 了解每个表的存储引擎特定的调整技术，索引技术和配置参数
    * 优化InnoDB只读事务
    * 避免以难以理解的方式转换查询，尤其是在优化程序自动执行某些相同转换的情况下
    * 如果使用基本准则之一不能轻松解决性能问题，请通过阅读EXPLAIN计划并调整索引，WHERE子句，连接子句等来调查特定查询的内部详细信息
    * 调整MySQL用于缓存的内存区域的大小和属性。通过有效地使用 InnoDB 缓冲池， MyISAM键高速缓存和MySQL查询高速缓存，重复查询的运行速度更快，因为第二次及其后的结果是从内存中检索到的
    * 即使对于使用缓存区域快速运行的查询，您也可能会进一步优化，以使它们需要更少的缓存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的同时用户，更大的请求等，而不会导致性能大幅下降
    * 处理锁定问题，其中其他会话同时访问表可能会影响查询速度
2. **WHERE子句优化**
* 删除不必要的括号
```sql
   ((a AND b) AND c OR (((a AND b) AND (c AND d)))) -> (a AND b AND c) OR (a AND b AND c AND d)
```
* 恒定折叠
```sql
  (a<b AND b=c) AND a=5 -> b>5 AND b=c AND a=5
```
* 恒定条件消除
```sql
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6) -> b=5 OR b=6
```
* 索引使用的常量表达式仅计算一次
* 从MyISAM 和MEMORY表中，COUNT(*)在没有where语句的单一的表直接检索该表信息。NOT NULL当仅与一个表一起使用时，对于任何表达式也可以执行此操作
* 早期检测无效的常量表达式。MySQL快速检测到某些 SELECT语句是不可能的，并且不返回任何行
* 如果您不使用GROUP BY或汇总功能（COUNT()， MIN()等），where与having可合并
* 对于联接中的每个表，WHERE构造一个简单 WHERE的表以获得表的快速 评估，并尽快跳过行
* 在查询中的所有其他表之前，首先读取所有常量表
* 通过尝试所有可能的方法，找到用于联接表的最佳联接组合
* 如果存在一个ORDER BY子句和另一个GROUP BY子句，或者如果 ORDER BY或GROUP BY 包含联接队列中第一个表以外的表中的列，则会创建一个临时表
* 如果使用SQL_SMALL_RESULT 修饰符，则MySQL使用内存中的临时表
* 查询每个表索引，并使用最佳索引，除非优化器认为使用表扫描更有效。一次使用扫描是基于最佳索引是否跨越了表的30％以上，但是固定百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I/O块大小
* 在某些情况下，MySQL甚至可以在不查询数据文件的情况下从索引中读取行。如果索引中使用的所有列都是数字，则仅索引树用于解析查询
* 在输出每一行之前，HAVING将跳过不匹配该子句的那些行
3. **limit语句优化**
* 如果你只选择了有限的几行，MySQL在某些情况下会使用索引，而通常情况下它更喜欢做一个全表扫描
* MySQL一旦向客户端发送了所需的行数，它将立即终止查询，除非您正在使用 SQL_CALC_FOUND_ROWS
* LIMIT 0快速返回一个空集。这对于检查查询的有效性很有用
* 如果没有为ORDER BY使用索引，但是也出现了LIMIT子句，那么优化器可能能够避免使用merge文件，并使用内存中的filesort操作对内存中的行进行排序
* 如果多行在列中具有相同的值ORDER BY，则服务器可以自由地以任何顺序返回这些行
4. **避免全表扫描**
* 该表是如此之小，以至于执行表扫描要比打扰键查找要快得多
* 对于索引列，ON或WHERE子句中没有可用的限制条件 
* 将索引列与常量值进行比较，并且MySQL已计算（基于索引树）（常量覆盖了表的很大一部分）并且表扫描会更快
* 使用更新的扫描表的键分布 ANALYZE TABLE tbl_name
* 使用FORCE INDEX强制走索引

### 优化子查询和派生表
* in/not in使用EXISTS替换
* 使用半连接转换优化子查询
```sql
# 子查询
SELECT class.class_num, class.class_name
FROM class INNER JOIN roster
WHERE class.class_num = roster.class_num;
# 优化后sql
SELECT class_num, class_name
FROM class
WHERE class_num IN (SELECT class_num FROM roster);
```
* 优化器使用materialization 来启用更有效的子查询处理。materialization 通过生成子查询结果作为临时表（通常在内存中）来加快查询的执行速度
* 优化派生表  EXPLAIN SELECT * FROM (SELECT * FROM t1) AS derived_t1;
  * 优化程序将派生表的实现推迟到查询执行期间需要它们的内容时为止，从而提高了性能
  * 在查询执行期间，优化器可以将索引添加到派生表中，以加快从中获取行的速度

### 优化insert/update/delete语句
#### insert语句
> 为了优化插入速度，请将许多小操作合并为一个大操作。理想情况下，您进行单个连接，一次发送许多新行的数据，并将所有索引更新和一致性检查延迟到最后
##### 插入行所需的时间由以下因素决定，其中数字表示近似比例
**这没有考虑到打开表的初始开销，该开销对于每个同时运行的查询都执行一次**

* 连接：（3）
* 向服务器发送查询：（2）
* 解析查询：（2）
* 插入行：（1×行大小）
* 插入索引：（1×索引数）
* 闭幕：（1）
##### 假设是b树索引，表的大小会使索引插入的速度降低log N
##### 加快插入速度
* 如果要同时从同一客户端插入许多行，请使用INSERT 具有多个VALUES列表的语句一次插入多个行。这比使用单独的单行INSERT 语句要快得多（某些情况下要快很多倍）。如果要将数据添加到非空表，则可以调整 bulk_insert_buffer_size 变量以使数据插入更快
* 从文本文件加载表格时，请使用 LOAD DATA。这通常比使用INSERT语句快20倍 
* 利用列具有默认值的事实。仅当要插入的值与默认值不同时才明确插入值。这减少了MySQL必须执行的解析并提高了插入速度
* InnoDB表插入优化
  * 将数据导入时InnoDB，请关闭自动提交模式，因为它会在每次插入时对磁盘执行日志刷新
  * 如果你对次要的key有唯一的约束，则可以通过在导入会话期间暂时关闭唯一性检查来加快表的导入 。对于大表，这可以节省大量磁盘I/O，因为InnoDB可以使用其更改缓冲区批量写入辅助索引记录。确保数据不包含重复的密钥
  * 如果FOREIGN KEY表中有约束，则可以通过在导入会话的持续时间内关闭外键检查来加快表的导入
  * 在具有自动增量列的表中进行批量插入时，请设置 innodb_autoinc_lock_mode为2而不是默认值1
  * 执行批量插入时，按PRIMARY KEY顺序插入行会更快

