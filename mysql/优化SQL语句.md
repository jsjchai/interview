## 优化SQL语句
* 以mysql版本5.6为例

### select语句
 1. **优化查询的主要考虑因素**
    * 为了使慢速SELECT ... WHERE查询更快，首先要检查的是是否可以添加索引
    * 隔离和调整查询中花费时间过多的任何部分，例如函数调用
    * 最小化查询中全表扫描的次数，特别是对于大表
    * 通过ANALYZE TABLE定期使用该语句来使表统计信息保持最新，因此优化器具有构造有效执行计划所需的信息
    * 了解每个表的存储引擎特定的调整技术，索引技术和配置参数
    * 优化InnoDB只读事务
    * 避免以难以理解的方式转换查询，尤其是在优化程序自动执行某些相同转换的情况下
    * 如果使用基本准则之一不能轻松解决性能问题，请通过阅读EXPLAIN计划并调整索引，WHERE子句，连接子句等来调查特定查询的内部详细信息
    * 调整MySQL用于缓存的内存区域的大小和属性。通过有效地使用 InnoDB 缓冲池， MyISAM键高速缓存和MySQL查询高速缓存，重复查询的运行速度更快，因为第二次及其后的结果是从内存中检索到的
    * 即使对于使用缓存区域快速运行的查询，您也可能会进一步优化，以使它们需要更少的缓存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的同时用户，更大的请求等，而不会导致性能大幅下降
    * 处理锁定问题，其中其他会话同时访问表可能会影响查询速度
2. **WHERE子句优化**
* 删除不必要的括号
```sql
   ((a AND b) AND c OR (((a AND b) AND (c AND d)))) -> (a AND b AND c) OR (a AND b AND c AND d)
```
* 恒定折叠
```sql
  (a<b AND b=c) AND a=5 -> b>5 AND b=c AND a=5
```
* 恒定条件消除
```sql
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6) -> b=5 OR b=6
```
* 索引使用的常量表达式仅计算一次
* 从MyISAM 和MEMORY表中，COUNT(*)在没有where语句的单一的表直接检索该表信息。NOT NULL当仅与一个表一起使用时，对于任何表达式也可以执行此操作
* 早期检测无效的常量表达式。MySQL快速检测到某些 SELECT语句是不可能的，并且不返回任何行
* 如果您不使用GROUP BY或汇总功能（COUNT()， MIN()等），where与having可合并
* 对于联接中的每个表，WHERE构造一个简单 WHERE的表以获得表的快速 评估，并尽快跳过行
* 在查询中的所有其他表之前，首先读取所有常量表
* 通过尝试所有可能的方法，找到用于联接表的最佳联接组合
* 如果存在一个ORDER BY子句和另一个GROUP BY子句，或者如果 ORDER BY或GROUP BY 包含联接队列中第一个表以外的表中的列，则会创建一个临时表
* 如果使用SQL_SMALL_RESULT 修饰符，则MySQL使用内存中的临时表
* 查询每个表索引，并使用最佳索引，除非优化器认为使用表扫描更有效。一次使用扫描是基于最佳索引是否跨越了表的30％以上，但是固定百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I/O块大小
* 在某些情况下，MySQL甚至可以在不查询数据文件的情况下从索引中读取行。如果索引中使用的所有列都是数字，则仅索引树用于解析查询
* 在输出每一行之前，HAVING将跳过不匹配该子句的那些行
3. **limit语句优化**
* 如果你只选择了有限的几行，MySQL在某些情况下会使用索引，而通常情况下它更喜欢做一个全表扫描
* MySQL一旦向客户端发送了所需的行数，它将立即终止查询，除非您正在使用 SQL_CALC_FOUND_ROWS
* LIMIT 0快速返回一个空集。这对于检查查询的有效性很有用
* 如果没有为ORDER BY使用索引，但是也出现了LIMIT子句，那么优化器可能能够避免使用merge文件，并使用内存中的filesort操作对内存中的行进行排序
* 如果多行在列中具有相同的值ORDER BY，则服务器可以自由地以任何顺序返回这些行
4. **避免全表扫描**
* 该表是如此之小，以至于执行表扫描要比打扰键查找要快得多
* 对于索引列，ON或WHERE子句中没有可用的限制条件 
* 将索引列与常量值进行比较，并且MySQL已计算（基于索引树）（常量覆盖了表的很大一部分）并且表扫描会更快
* 使用更新的扫描表的键分布 ANALYZE TABLE tbl_name
* 使用FORCE INDEX强制走索引

### 优化子查询和派生表
* in/not in使用EXISTS替换
* 使用半连接转换优化子查询
```sql
# 子查询
SELECT class.class_num, class.class_name
FROM class INNER JOIN roster
WHERE class.class_num = roster.class_num;
# 优化后sql
SELECT class_num, class_name
FROM class
WHERE class_num IN (SELECT class_num FROM roster);
```
