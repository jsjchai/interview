## 事务
> 事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试
### 数据库可能面临的问题
* 数据库软件或硬件可能随时失效
* 应用程序可能随时崩溃（包括一系列操作执行到某一步）
* 应用与数据库节点之间的链接可能随时会中断，数据库节点之间也存在同样问题
* 多个客户端可能同时写入数据库，导致数据覆盖
* 客户端可能读到一些无意义的、部分更新的数据
* 客户端之间由于边界条件竞争锁引入的各种奇怪问题
### 目的
* 简化应用层的编程模型
* 安全性保证

### ACID
* 原子性
  * 在出错时中止事务，并将部分完成的写入全部丢弃 
* 一致性
  * 对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或恒等条件） 
* 隔离性
  * 并发执行的多个事务相互隔离，不能互相交叉 
* 持久性
  * 保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失 

### 弱隔离级别

### 只读事务遇到并发写时
* 读-提交
  * 读数据库，只能看到已成功提交的数据（防止“脏读”）
  * 写数据库，只能覆盖已成功提交的数据（防止“脏写”）
  * 数据库通常采用行级锁来防止脏写
  * 防止脏读
    * 对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。在事务提交之前，所有其他读操作都读取旧值；仅当写事务提交之后，才会切换到读取新值  
* 快照级别隔离与可重复读
  * 不可重复读取或读倾斜
    * 快照级别隔离-每个事务读从数据库的一致性快照中读取，事务一开始所看到是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到该特定时间点的旧数据
* 实现快照级别隔离
  * 写锁来防止脏写
  * MVCC来防止脏读
* 多版本快照如何支持索引
  * 索引直接指向对象的所有版本，然后想办法过滤当前事务不可见的那些版本
  * 追加/写时复制 追加式B-tree
* 快照级别隔离对于只读事务特别有效
  * 可重复读  
              
### 防止更新丢失-并发写冲突
> 当有两个事务在同样的数据对象上执行类似操作时，由于隔离性，第二个写操作并不包括第一个写事务修改后值，最终导致第一个事务的修改值丢失
* 显示加锁
* 自动检测更新丢失 CAS  

### 写倾斜与幻读
> 不同的数据对象存在某种竞争状态
#### 例子
* 会议室预定系统
  * 假设要求同一时间、同一个会议室不能被预订两次。避免多人同时预订
* 声明一个用户名 
#### 幻读
* 写倾斜导致幻读
* 快照级别隔离只能避免只读查询的幻读

#### 解决-实体化冲突
* 加锁
* for update
* 不推举使用实体化冲突，大多数采用可串行化隔离

### 可串行化隔离
* 单线程循环来执行事务
* 串行化算法-两阶段加锁（2PL）
  * 锁的强制性更高
